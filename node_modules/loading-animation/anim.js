const colors = require('colors/safe');
var textB = '', textA = '';
class LoadingAnimation{
    constructor(text = '', props = 'blue bold'){
        if (typeof text == 'string'){
            if (text.length) textB = text + ' ';
            textA = '';
        } else if (Array.isArray(text)){
            if (text[0]){
                if (text[0].length) textB = text[0] + ' ';
            } else textB = '';
            if (text[1]){
                if (text[1].length) textA = ' ' + text[1];
            } else textA = '';
        } else {
            throw new TypeError('text is not of type String or Array');
        }
        function resetIfColor(text, color){
            if (typeof colors[color]) return colors[color](text); else return text;
        }
        function colorize(str, colors){
            colors.forEach(color => {
                str = resetIfColor(str, color);
            })
            return str;
        }
        this.internalTimer = (() => {
            var symbols = ((arr, colors) => {
                arr.forEach((symbol, i) => {
                    arr[i] = colorize(symbol, colors);
                });
                return arr;
            })(['⣾', '⣷', '⣯', '⣟', '⡿', '⢿', '⣻', '⣽'], props.split(' '));
            var i = 0;
            return setInterval(() => {
                process.stdout.cursorTo(0);
                process.stdout.write(textB + symbols[i++] + textA);
                i &= symbols.length - 1;
            }, 50);
        })();
    }
    stop(stopText = false){
        clearInterval(this.internalTimer);
        process.stdout.clearLine();
        process.stdout.cursorTo(0);
        process.stdout.write(textB);
        if (stopText && stopText.length){
            console.log(stopText + textA);
        } else {
            process.stdout.moveCursor(-1, 0);
            console.log(textA);
        }
    }
    set textBefore(newVal){
        process.stdout.clearLine();
        textB = newVal;
    }
    set textAfter(newVal){
        process.stdout.clearLine();
        textA = newVal;
    }
    get textBefore(){
        return textB;
    }
    get textAfter(){
        return textA;
    }
}
module.exports = LoadingAnimation;